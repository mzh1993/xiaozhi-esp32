# ESP32项目物联网功能实现分析

## 1. 概述

本项目采用MCP（Model Context Protocol）协议实现物联网功能，通过标准化的JSON-RPC 2.0格式实现设备与后台的通信和控制。整个物联网系统由以下几个核心组件构成：

- **McpServer**: MCP协议服务器，负责工具注册和消息处理
- **LampController**: 物联网灯控制器，作为具体设备控制示例
- **Property/PropertyList**: 参数定义和管理系统
- **McpTool**: 工具定义和回调机制

## 2. MCP协议架构

### 2.1 协议基础

MCP协议基于JSON-RPC 2.0，定义了设备与AI后台的标准通信格式：

```json
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "self.lamp.turn_on",
    "arguments": {}
  },
  "id": 1
}
```

### 2.2 核心组件分析

#### 2.2.1 McpServer类

**功能**: MCP协议服务器，管理所有注册的工具和消息处理

**关键方法**:
```cpp
class McpServer {
public:
    static McpServer& GetInstance();  // 单例模式
    
    // 工具注册方法
    void AddTool(const std::string& name, 
                 const std::string& description, 
                 const PropertyList& properties, 
                 std::function<ReturnValue(const PropertyList&)> callback);
    
    // 消息处理
    void ParseMessage(const std::string& message);
    void ParseMessage(const cJSON* json);
};
```

**工作流程**:
1. 设备启动时注册各种工具（功能）
2. 接收后台发送的JSON-RPC消息
3. 解析消息并调用对应的工具
4. 返回执行结果给后台

#### 2.2.2 Property/PropertyList系统

**Property类**: 定义工具参数的类型和约束

```cpp
class Property {
private:
    std::string name_;           // 参数名称
    PropertyType type_;          // 参数类型（布尔/整数/字符串）
    std::variant<bool, int, std::string> value_;  // 参数值
    bool has_default_value_;     // 是否有默认值
    std::optional<int> min_value_;  // 整数最小值（可选）
    std::optional<int> max_value_;  // 整数最大值（可选）
};
```

**PropertyList类**: 管理多个Property的容器

```cpp
class PropertyList {
private:
    std::vector<Property> properties_;
    
public:
    void AddProperty(const Property& property);
    const Property& operator[](const std::string& name) const;
    std::vector<std::string> GetRequired() const;  // 获取必需参数
    std::string to_json() const;  // 转换为JSON格式
};
```

## 3. LampController详细分析

### 3.1 类结构

```cpp
class LampController {
private:
    bool power_ = false;         // 灯的状态（开/关）
    gpio_num_t gpio_num_;       // 控制灯的GPIO引脚

public:
    LampController(gpio_num_t gpio_num);  // 构造函数
};
```

### 3.2 初始化过程

```cpp
LampController(gpio_num_t gpio_num) : gpio_num_(gpio_num) {
    // 1. 配置GPIO引脚
    gpio_config_t config = {
        .pin_bit_mask = (1ULL << gpio_num_),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE,
    };
    ESP_ERROR_CHECK(gpio_config(&config));
    gpio_set_level(gpio_num_, 0);  // 初始状态为关闭

    // 2. 获取MCP服务器实例
    auto& mcp_server = McpServer::GetInstance();
    
    // 3. 注册三个工具
    RegisterTools();
}
```

### 3.3 工具注册分析

LampController注册了三个MCP工具：

#### 3.3.1 获取灯状态工具

```cpp
mcp_server.AddTool("self.lamp.get_state", 
                   "Get the power state of the lamp", 
                   PropertyList(),  // 无参数
                   [this](const PropertyList& properties) -> ReturnValue {
                       return power_ ? "{\"power\": true}" : "{\"power\": false}";
                   });
```

**功能**: 查询灯的当前开关状态
**调用方式**: `self.lamp.get_state`
**参数**: 无
**返回值**: JSON格式的状态信息

#### 3.3.2 开灯工具

```cpp
mcp_server.AddTool("self.lamp.turn_on", 
                   "Turn on the lamp", 
                   PropertyList(),  // 无参数
                   [this](const PropertyList& properties) -> ReturnValue {
                       power_ = true;
                       gpio_set_level(gpio_num_, 1);  // 设置GPIO高电平
                       return true;
                   });
```

**功能**: 打开灯
**调用方式**: `self.lamp.turn_on`
**参数**: 无
**返回值**: 布尔值表示操作是否成功

#### 3.3.3 关灯工具

```cpp
mcp_server.AddTool("self.lamp.turn_off", 
                   "Turn off the lamp", 
                   PropertyList(),  // 无参数
                   [this](const PropertyList& properties) -> ReturnValue {
                       power_ = false;
                       gpio_set_level(gpio_num_, 0);  // 设置GPIO低电平
                       return true;
                   });
```

**功能**: 关闭灯
**调用方式**: `self.lamp.turn_off`
**参数**: 无
**返回值**: 布尔值表示操作是否成功

## 4. 工具注册机制详解

### 4.1 AddTool方法签名

```cpp
void AddTool(const std::string& name,           // 工具名称
             const std::string& description,     // 工具描述
             const PropertyList& properties,     // 参数列表
             std::function<ReturnValue(const PropertyList&)> callback);  // 回调函数
```

### 4.2 工具注册流程

1. **创建McpTool对象**:
   ```cpp
   AddTool(new McpTool(name, description, properties, callback));
   ```

2. **检查重复注册**:
   ```cpp
   if (std::find_if(tools_.begin(), tools_.end(), 
                    [tool](const McpTool* t) { return t->name() == tool->name(); }) 
       != tools_.end()) {
       ESP_LOGW(TAG, "Tool %s already added", tool->name().c_str());
       return;
   }
   ```

3. **添加到工具列表**:
   ```cpp
   tools_.push_back(tool);
   ```

### 4.3 工具调用流程

1. **接收JSON-RPC消息**:
   ```json
   {
     "jsonrpc": "2.0",
     "method": "tools/call",
     "params": {
       "name": "self.lamp.turn_on",
       "arguments": {}
     },
     "id": 1
   }
   ```

2. **查找工具**:
   ```cpp
   auto tool_iter = std::find_if(tools_.begin(), tools_.end(), 
                                [&tool_name](const McpTool* tool) { 
                                    return tool->name() == tool_name; 
                                });
   ```

3. **参数验证**:
   ```cpp
   for (auto& argument : arguments) {
       // 检查必需参数是否存在
       // 验证参数类型和范围
   }
   ```

4. **异步执行工具**:
   ```cpp
   tool_call_thread_ = std::thread([this, id, tool_iter, arguments]() {
       try {
           ReplyResult(id, (*tool_iter)->Call(arguments));
       } catch (const std::exception& e) {
           ReplyError(id, e.what());
       }
   });
   ```

## 5. 实际应用示例

### 5.1 在CompactWifiBoard中的使用

```cpp
void InitializeTools() {
    static LampController lamp(LAMP_GPIO);  // 创建灯控制器实例
}
```

**工作流程**:
1. 创建LampController实例时自动注册三个MCP工具
2. 后台可以通过MCP协议调用这些工具
3. 工具执行时会控制GPIO引脚状态

### 5.2 典型调用序列

1. **后台获取工具列表**:
   ```json
   {
     "jsonrpc": "2.0",
     "method": "tools/list",
     "params": {"cursor": ""},
     "id": 1
   }
   ```

2. **后台调用开灯功能**:
   ```json
   {
     "jsonrpc": "2.0",
     "method": "tools/call",
     "params": {
       "name": "self.lamp.turn_on",
       "arguments": {}
     },
     "id": 2
   }
   ```

3. **设备响应**:
   ```json
   {
     "jsonrpc": "2.0",
     "id": 2,
     "result": {
       "content": [{"type": "text", "text": "true"}],
       "isError": false
     }
   }
   ```

## 6. 扩展性设计

### 6.1 添加新设备控制器

要添加新的物联网设备，只需：

1. **创建新的控制器类**:
   ```cpp
   class FanController {
   private:
       bool power_ = false;
       int speed_ = 0;
       gpio_num_t gpio_num_;
   
   public:
       FanController(gpio_num_t gpio_num) : gpio_num_(gpio_num) {
           // 配置GPIO
           // 注册MCP工具
       }
   };
   ```

2. **注册相关工具**:
   ```cpp
   mcp_server.AddTool("self.fan.turn_on", "Turn on the fan", 
                      PropertyList(), [this](const PropertyList&) -> ReturnValue {
                          power_ = true;
                          gpio_set_level(gpio_num_, 1);
                          return true;
                      });
   
   mcp_server.AddTool("self.fan.set_speed", "Set fan speed", 
                      PropertyList({Property("speed", kPropertyTypeInteger, 50, 0, 100)}), 
                      [this](const PropertyList& properties) -> ReturnValue {
                          speed_ = properties["speed"].value<int>();
                          // 设置PWM占空比
                          return true;
                      });
   ```

3. **在主板中初始化**:
   ```cpp
   void InitializeTools() {
       static FanController fan(FAN_GPIO);
   }
   ```

### 6.2 参数验证机制

系统支持多种参数验证：

1. **类型检查**: 自动验证参数类型（布尔/整数/字符串）
2. **范围检查**: 整数参数可设置最小值和最大值
3. **必需参数**: 自动检查必需参数是否提供
4. **默认值**: 支持为可选参数设置默认值

## 7. 错误处理机制

### 7.1 参数验证错误

```cpp
if (!argument.has_default_value() && !found) {
    ESP_LOGE(TAG, "tools/call: Missing valid argument: %s", argument.name().c_str());
    ReplyError(id, "Missing valid argument: " + argument.name());
    return;
}
```

### 7.2 工具不存在错误

```cpp
if (tool_iter == tools_.end()) {
    ESP_LOGE(TAG, "tools/call: Unknown tool: %s", tool_name.c_str());
    ReplyError(id, "Unknown tool: " + tool_name);
    return;
}
```

### 7.3 异常处理

```cpp
try {
    ReplyResult(id, (*tool_iter)->Call(arguments));
} catch (const std::exception& e) {
    ESP_LOGE(TAG, "tools/call: %s", e.what());
    ReplyError(id, e.what());
}
```

## 8. 性能优化

### 8.1 异步执行

工具调用在独立线程中执行，避免阻塞主线程：

```cpp
tool_call_thread_ = std::thread([this, id, tool_iter, arguments]() {
    // 工具执行逻辑
});
tool_call_thread_.detach();
```

### 8.2 内存管理

- 使用智能指针管理工具对象
- 及时释放JSON对象避免内存泄漏
- 使用RAII原则管理资源

## 9. 总结

本项目的物联网功能实现具有以下特点：

1. **标准化**: 基于MCP协议，提供标准化的设备控制接口
2. **模块化**: 每个设备控制器独立封装，易于扩展
3. **类型安全**: 强类型参数系统，减少运行时错误
4. **异步处理**: 工具调用不阻塞主线程
5. **错误处理**: 完善的错误处理和日志记录
6. **易于使用**: 简单的API设计，快速集成新设备

这种设计使得项目能够轻松支持各种物联网设备，同时保持代码的清晰性和可维护性。
