# 系统整体调度优化方案文档

基于《触摸事件语音播报失败问题分析.md》的结论，提出系统级调度优化方案，以提升音频首包可靠性、降低模块间竞态、并改善功耗与可维护性。

## 1. 目标与范围

- 音频回放首包可靠、可预期：消除“有文本无音频”的偶发情况。
- 降低多源调度导致的时序不确定性：统一任务/定时器管理。
- 降低 Timer Service 负载与阻塞风险：定时器回调零阻塞。
- 保障音频/网络关键路径优先级：不被外设（耳朵马达）干扰。

适用范围：`main/application.*`、`main/audio/*`、`main/protocols/*`、`main/ear/*`、板级 `AudioCodec` 实现。

## 2. 当前主要问题（摘要）

- 触摸链路：发送 `listen+detect` 后立即 `listen+start` 易与服务端期望冲突，导致不下发音频；随后命中自动省电关断，形成“启用→等待→关断”。
- FreeRTOS 使用分散：App 与 Ear 各自使用任务/定时器/互斥，Timer Service 回调与主状态机/协议回调时序交叠，增加不确定性。
- 电源策略耦合松散：`AUDIO_POWER_TIMEOUT_MS` 基于“最后播放时间”，在无首包期间会误关；部分板级还存在一次性关断定时器。

## 3. 设计原则

1) 中心化调度：核心任务只在 App/Audio/Protocol 层创建，外设模块尽量不新建任务。
2) 关键路径优先：音频编解码/网络回调的优先级高于外设动作。
3) 定时回调零阻塞：定时器回调只做事件投递，不做耗时/阻塞调用。
4) 状态机一致：跨模块状态迁移由 App 主循环串行化，减少竞态。
5) 省电策略可感知会话：speaking 期间抑制自动关断；收到 `tts start` 立即刷新首包等待计时。

## 4. 任务与优先级规划（建议）

优先级从高到低（示意）：

1. 协议网络回调 / UDP 音频接收（Protocol 内部回调，不单独任务时由网络栈线程承载）
2. Opus 编解码任务（`AudioService::OpusCodecTask`）
3. 音频输出任务（`AudioService::AudioOutputTask`）与输入任务（可与 Processor 共用）
4. App 主事件循环（`MainEventLoop`）
5. 外设 Worker Task（耳朵、灯光等统一工作队列）
6. UI 及低优先级服务

说明：具体数值按现有系统优先级表调整，但需保证 1-3 > 4 > 5。

## 5. 外设（耳朵）调度改造

- 统一 Worker Task：在 App 创建一个“外设工作任务”，Ear 通过队列提交“动作事件”。
- 单定时器推进序列：Ear 仅保留一根软件定时器维护状态机；回调中只投递“下一步动作”到 Worker，不直接操控 GPIO/阻塞。
- 互斥最小化：仅保护共享标志（如 `sequence_active_`、`emotion_action_active_`、`moving_both_`），避免跨模块大锁。
- 状态协同：情绪触发/触摸触发均经 App 主循环判定（例如 speaking 首包窗口期延后大动作，降低电源波动与时序抖动）。

## 6. 触摸链路优化（关键）

- 去监听化：触摸路径不立即 `SetListeningMode`。流程调整为：
  1) 打开音频通道（如需）；
  2) 发送 `listen+detect`（触摸文本）；
  3) 等待服务端 `tts start` → 切 `speaking`；
  4) 若超时未收到 `tts start`，再按策略进入 listening 或提示失败。
- speaking 期间保护：进入 speaking 即 `EnableOutput(true)`；同时抑制自动关断（见第 7 节）。

## 7. 音频电源与首包保护

- Speaking 期间抑制自动关断：
  - 在 `device_state_ == speaking` 时，`CheckAndUpdateAudioPowerState()` 不关闭输出；或将 `AUDIO_POWER_TIMEOUT_MS` 动态拉长（如 60s）。
- 刷新首包计时：
  - 收到 `tts start` 即刷新 `last_output_time_`，为首包到达预留缓冲时间。
- 板级一次性关断协调：
  - 若板级实现（如 `AdcPdmAudioCodec`）有一次性关断定时器，在 speaking 期间延后或禁用；由 `AudioService` 统一负责输出状态。

## 8. Timer Service 负载控制

- 耳朵序列尽量使用单定时器 + 改期（`xTimerChangePeriod`）。
- 定时器回调仅投递轻量事件到 Worker（可用 `xTimerPendFunctionCall`）。
- 严禁定时器回调里：`vTaskDelay`、阻塞 I/O、重计算、跨模块调用。

## 9. 协议/音频回调一致性

- `OnIncomingAudio` 与 MQTT/WebSocket 回调内仅做队列投递，避免重逻辑。
- App 状态机的切换只在主循环中执行。
- 对 `goodbye` 等通道关闭消息：speaking 或最近 `tts start` 的 5s 窗口内优先尝试重开通道并维持输出开启。

## 10. 监控与回退

- 首包监控：统计“`tts start` → 首个 UDP 包到达”耗时，超阈值打印一次（仅调试版）。
- 失败回退：若触摸链路 2-3 次连续超时，临时启用“触摸→直接 speaking 保护模式”（跳过 listen+start），以提高可用性。

## 11. 具体代码修改点

### 11.1 触摸事件流程分析与优化设计

#### 11.1.1 用户期待的流程

**用户期待的触摸事件流程**：

1. 用户触摸按钮
2. 系统把触摸事件发到调度器，由调度器决定所有events的中断和执行顺序
3. 调度ear驱动完成动作，期间不能阻塞其他进程
4. （利用原有函数）调用网络发送触摸文本，等待服务器回复等过程
5. 监听到TTS音频信息，播放音频（优先级较高）
6. 有可能ear动作和音频播放是并行一起在执行的！

**流程严谨性评估**：✅ **非常严谨，符合系统设计原则**

**优点**：

- ✅ **统一调度**：所有事件通过调度器管理，避免竞态
- ✅ **非阻塞**：ear动作不阻塞其他进程
- ✅ **并行执行**：ear动作和音频播放可以并行，提升用户体验
- ✅ **优先级明确**：音频播放优先级高于ear动作

#### 11.1.2 当前实现的问题

**问题1：缺少统一调度器**

- **当前实现**：`TriggerEarActionForTouch()` 在按钮回调中直接同步执行，不在调度器中
- **问题**：ear动作和网络发送是串行的，不是并行的；没有统一的调度器来管理所有事件的执行顺序

**问题2：ear动作可能阻塞**

- **当前实现**：`TriggerEmotion()` 虽然启动定时器，但序列初始化可能涉及状态检查和互斥锁
- **问题**：如果ear控制器正在执行其他动作，可能阻塞或冲突

**问题3：执行顺序不明确**

- **当前流程**：ear动作在按钮回调中执行，网络发送在主循环中执行
- **问题**：两者不是通过统一调度器协调的；如果主循环繁忙，网络发送可能延迟，但ear动作已经执行

#### 11.1.3 优化后的流程设计

**理想流程**：

```
触摸按钮
    ↓
PostTouchEvent() → 调度器（主循环）
    ↓
调度器决定执行顺序：
    1. 立即调度ear动作到外设Worker Task（非阻塞，优先级5）
    2. 立即调度网络发送到主循环（优先级3，但ear动作已提交）
    ↓
并行执行：
    - 外设Worker Task执行ear动作（不阻塞主循环）
    - 主循环处理网络发送（不阻塞ear动作）
    ↓
服务器响应 → 网络回调 → 调度器
    ↓
调度器调度音频播放（优先级4，高于ear动作）
    ↓
并行执行：
    - 音频播放任务执行（优先级4）
    - ear动作继续执行（优先级5，不干扰音频）
```

**关键改进**：

1. ✅ **统一调度**：所有事件通过 `Schedule()` 或外设Worker Task队列统一管理
2. ✅ **非阻塞**：ear动作通过外设Worker Task执行，不阻塞主循环
3. ✅ **并行执行**：ear动作和网络发送/音频播放可以并行
4. ✅ **优先级明确**：音频播放（优先级4）高于ear动作（优先级5）

#### 11.1.4 `ProcessTouchEvent` 调度策略与改造要点

- 统一触摸→调度→执行链路：任何触摸来源都只调用 `PostTouchEvent()`，由主循环串行化执行，避免跨线程竞态。
- 去监听化落地：`HandleTouchEventInIdleState()` 不立即 `SetListeningMode`，发送触摸文本后使用 `esp_timer` 做非阻塞超时（推荐3s，可配置），收到 `tts start` 即切 `speaking` 并取消超时，超时才进入 `listening`（已在修改点2/3/6覆盖）。
- 监听停止顺序：从 `listening` 切换时，先 `protocol_->SendStopListening()`，再（同一闭包内）进行状态切换，确保“协议→状态”的一致顺序，避免跨 tick 抖动。
- 重试退避与上限：`connecting/default` 分支的二次 `Schedule(ProcessTouchEvent)` 增加退避和最大次数，避免在弱网/状态不稳时刷任务队列。
  - 建议线性退避（50→100→200ms）或轻微抖动的指数退避；最多3-5次，超过则丢弃或合并。
- 触摸合并/去抖：在主循环侧维护“触摸窗口（例如200ms）”，合并同类触摸，避免重复网络发送与耳朵动作。
- speaking中断保护：`speaking` 分支 `AbortSpeaking()` 后，增加“短延迟（100-200ms）或等待播放队列清空/通道关闭”的保护，再进入下一步触摸处理，降低与回放残留的竞争。
- 外设并行：耳朵动作通过“外设Worker Task”队列执行，Timer 回调仅投递事件，不直接操控 GPIO（见修改点7/8/9/10）。
- 主循环零阻塞：严禁在主循环路径与定时器回调中出现 `vTaskDelay`/阻塞I/O/重计算，使用 `esp_timer` + `Schedule()` 组合实现异步推进。

示例（退避重试伪代码）：

```
// 记录每个触摸事件的 attempt 次数与首次时间戳
Schedule([this, message, attempt]() {
  if (device_state_ == kDeviceStateConnecting && attempt < 5) {
    uint32_t backoff_ms = 50u << attempt; // 50,100,200,400,800ms
    esp_timer_start_once(retry_timer_, backoff_ms * 1000);
    // 在 retry_timer_ 回调里再次 Schedule(ProcessTouchEvent, attempt+1)
    return;
  }
  // 其他逻辑...
});
```

### 11.2 触摸链路优化（阶段A - 关键修改）

#### 修改点1：`main/boards/astronaut-toys-esp32s3/astronaut-toys-esp32s3.cc` - 触摸按钮回调优化

**位置**：`468:557:main/boards/astronaut-toys-esp32s3/astronaut-toys-esp32s3.cc`

**当前问题**：

- 触摸按钮回调中直接调用 `TriggerEarActionForTouch()`，ear动作在按钮回调中同步执行
- ear动作和网络发送是串行的，不是并行的
- 没有通过统一调度器管理

**修改方案**：

```cpp
// 修改前：直接调用ear动作
head_touch_button_.OnClick([this]() {
    TriggerEarActionForTouch("head", false);  // 直接调用，阻塞按钮回调
    Application::GetInstance().PostTouchEvent(action_text);
});

// 修改后：通过调度器统一管理
head_touch_button_.OnClick([this]() {
    std::string action_text = "摸摸头哦~";
  
    // 1. 将ear动作提交到外设Worker Task（非阻塞，优先级5）
    // 注意：需要在外设Worker Task实现后使用
    auto& app = Application::GetInstance();
    app.SchedulePeripheralAction(PeripheralAction::kEarEmotion, "head", false);
  
    // 2. 将网络发送提交到主循环（优先级3）
    app.PostTouchEvent(action_text);
  
    // 现在ear动作和网络发送可以并行执行
});
```

**或者更简单的方案（阶段A快速实现）**：

```cpp
// 如果外设Worker Task还未实现，可以先通过Schedule延迟执行ear动作
head_touch_button_.OnClick([this]() {
    std::string action_text = "摸摸头哦~";
  
    // 1. 将ear动作提交到主循环（非阻塞，但优先级较低）
    Application::GetInstance().Schedule([this]() {
        TriggerEarActionForTouch("head", false);
    });
  
    // 2. 将网络发送提交到主循环
    Application::GetInstance().PostTouchEvent(action_text);
  
    // 注意：这种方式ear动作和网络发送都在主循环中串行执行
    // 但至少不会阻塞按钮回调，且执行顺序可控
});
```

**关键变更**：

- ✅ **移除直接调用**：不再在按钮回调中直接调用 `TriggerEarActionForTouch()`
- ✅ **统一调度**：ear动作和网络发送都通过调度器管理
- ✅ **非阻塞**：按钮回调立即返回，不阻塞触摸传感器

**阶段B优化**：

- 实现外设Worker Task后，ear动作通过外设Worker Task执行（优先级5）
- 网络发送在主循环中执行（优先级3）
- 两者可以真正并行执行

#### 修改点2：`main/application.cc` - `HandleTouchEventInIdleState()`

**位置**：`1114:1171:main/application.cc`

**当前问题**：

- 第1145行：触摸事件后立即调用 `SetListeningMode(kListeningModeAutoStop)`，导致发送 `listen+start`，与服务端期望冲突。

**状态切换机制说明**：

1. **触摸事件流程**：

   - 触摸传感器 → `PostTouchEvent()` → `Schedule()` → 主循环执行 `ProcessTouchEvent()` → `HandleTouchEventInIdleState()`
   - `HandleTouchEventInIdleState()` 发送触摸文本消息到服务器
2. **服务器响应流程**（异步，时长未知）：

   - 服务器收到触摸文本 → 处理并生成响应 → 通过 MQTT/WebSocket 发送 JSON 消息（`tts start`）
   - 网络层回调 `protocol_->OnIncomingJson()` 被触发（可能在网络任务中执行）
   - 回调中调用 `Schedule([this]() { SetDeviceState(kDeviceStateSpeaking); })`
   - 主循环在 `MainEventLoop()` 中串行执行，将状态切换为 `kDeviceStateSpeaking`
3. **关键点**：

   - 状态切换是**异步的**，通过 `Schedule()` 在主循环中串行化
   - 服务器响应时间**未知**（通常几百毫秒到2-3秒，网络差时可能更长）
   - **不能阻塞主循环**等待状态切换，否则会影响其他任务

**修改方案（非阻塞）**：

```cpp
// 在 application.h 中添加成员变量
esp_timer_handle_t touch_timeout_timer_ = nullptr;
uint64_t touch_event_time_ms_ = 0;  // 触摸事件时间戳

// 在 application.cc 构造函数中创建定时器
Application::Application() {
    // ... 现有代码 ...
  
    // 创建触摸超时定时器
    esp_timer_create_args_t touch_timeout_timer_args = {
        .callback = [](void* arg) {
            Application* app = (Application*)arg;
            app->OnTouchTimeout();
        },
        .arg = this,
        .dispatch_method = ESP_TIMER_TASK,
        .name = "touch_timeout",
        .skip_unhandled_events = true
    };
    esp_timer_create(&touch_timeout_timer_args, &touch_timeout_timer_);
}

// 修改 HandleTouchEventInIdleState
void Application::HandleTouchEventInIdleState(const std::string& message) {
    ESP_LOGI(TAG, "Handling touch event in idle state: %s", message.c_str());
  
    // 1. 确保音频通道打开
    if (!protocol_ || !protocol_->IsAudioChannelOpened()) {
        ESP_LOGI(TAG, "Opening audio channel for touch event");
        SetDeviceState(kDeviceStateConnecting);
      
        if (!protocol_->OpenAudioChannel()) {
            ESP_LOGE(TAG, "Failed to open audio channel for touch event");
            SetDeviceState(kDeviceStateIdle);
            return;
        }
    }
  
    // 2. 发送触摸事件消息
    if (protocol_) {
        ESP_LOGI(TAG, "Sending touch event message: %s", message.c_str());
        protocol_->SendMessage(message);
      
        // 记录触摸事件时间
        touch_event_time_ms_ = esp_timer_get_time() / 1000;
      
        // 3. 启动超时定时器（非阻塞）
        // 超时时间：3秒（可根据实际情况调整）
        // 如果服务器在3秒内返回 tts start，定时器会被取消
        esp_timer_stop(touch_timeout_timer_);
        esp_timer_start_once(touch_timeout_timer_, 3000000); // 3秒 = 3000000微秒
      
        ESP_LOGI(TAG, "Touch event sent, waiting for tts start (timeout: 3s)");
    } else {
        ESP_LOGE(TAG, "Protocol not available for touch event");
        return;
    }
  
    // 4. 不再立即切换到 listening 状态
    // 等待服务器 tts start 响应，或超时处理
  
    // 5. 确保音频输出启用（为首包做准备）
    auto codec = Board::GetInstance().GetAudioCodec();
    if (codec) {
        codec->EnableOutput(true);
    }
}

// 新增：触摸超时处理函数
void Application::OnTouchTimeout() {
    Schedule([this]() {
        // 检查是否已经进入 speaking 状态
        if (device_state_ == kDeviceStateSpeaking) {
            ESP_LOGI(TAG, "Touch timeout: already in speaking state, canceling timeout");
            return; // 已经收到 tts start，无需处理超时
        }
      
        // 检查是否在超时期间收到了 tts start（但状态还未切换）
        uint64_t current_time_ms = esp_timer_get_time() / 1000;
        bool recent_tts_start = (last_tts_start_time_ms_ > 0 && 
                                 last_tts_start_time_ms_ >= touch_event_time_ms_ &&
                                 (current_time_ms - last_tts_start_time_ms_) < 1000); // 1秒内
      
        if (recent_tts_start) {
            ESP_LOGI(TAG, "Touch timeout: tts start received recently, waiting for state change");
            // tts start 已收到，但状态可能还在切换中，再等待1秒
            esp_timer_start_once(touch_timeout_timer_, 1000000); // 再等1秒
            return;
        }
      
        // 确实超时，进入 listening 模式作为回退
        ESP_LOGW(TAG, "Touch timeout: no tts start received after 3s, entering listening mode");
        SetListeningMode(kListeningModeAutoStop);
    });
}

// 在 tts start 处理中取消超时定时器
// 修改 OnIncomingJson 中的 tts start 处理
if (strcmp(state->valuestring, "start") == 0) {
    Schedule([this]() {
        // 取消触摸超时定时器（如果还在运行）
        if (touch_timeout_timer_) {
            esp_timer_stop(touch_timeout_timer_);
        }
      
        // ... 现有的 tts start 处理代码 ...
    });
}
```

**关键变更**：

- ✅ **非阻塞设计**：使用 `esp_timer` 而非 `vTaskDelay`，不阻塞主循环
- ✅ **异步状态检查**：超时回调中通过 `Schedule()` 检查状态，避免竞态
- ✅ **智能超时**：3秒超时（可配置），如果收到 tts start 但状态未切换，再等待1秒
- ✅ **移除立即 listening**：不再立即调用 `SetListeningMode`，等待服务器响应

**超时时间说明**：

- **3秒超时**：基于实际测试，正常网络下服务器响应通常在500ms-2秒内
- **可配置**：可通过宏定义 `TOUCH_TIMEOUT_MS` 调整
- **双重检查**：超时后检查 `last_tts_start_time_ms_`，避免状态切换延迟导致的误判

#### 修改点3：`main/application.cc` - `OnIncomingJson()` - tts start 处理

**位置**：`471:518:main/application.cc`

**当前状态**：已实现部分优化（第481行记录 `last_tts_start_time_ms_`，第502行强制启用输出）

**需要补充**：

1. **取消触摸超时定时器**（配合修改点1）：

   - 在 tts start 处理开始时，立即取消触摸超时定时器
   - 避免超时回调误触发
2. **刷新 `AudioService` 的 `last_output_time_`**：

   - 第481行后添加：刷新 `AudioService` 的 `last_output_time_`，为首包预留缓冲时间
   - 需要添加 `AudioService::RefreshOutputTime()` 方法

**修改方案**：

```cpp
if (strcmp(state->valuestring, "start") == 0) {
    Schedule([this]() {
        // 1. 取消触摸超时定时器（如果还在运行）
        if (touch_timeout_timer_) {
            esp_timer_stop(touch_timeout_timer_);
            ESP_LOGI(TAG, "Touch timeout timer cancelled due to tts start");
        }
      
        aborted_ = false;
      
        // 2. 记录 tts start 时间，用于通道关闭保护
        last_tts_start_time_ms_ = esp_timer_get_time() / 1000;
      
        // 3. 刷新音频输出时间，为首包到达预留缓冲
        audio_service_.RefreshOutputTime();
      
        // ... 现有的其他代码：确保音频通道打开、启用输出、切换状态 ...
    });
}
```

### 11.3 音频电源管理优化（阶段A - 关键修改）

#### 修改点4：`main/audio/audio_service.cc` - `CheckAndUpdateAudioPowerState()`

**位置**：`639:652:main/audio/audio_service.cc`

**当前问题**：

- 第646行：仅基于 `last_output_time_` 判断，speaking 状态下可能误关闭输出

**修改方案**：

```cpp
void AudioService::CheckAndUpdateAudioPowerState() {
    auto now = std::chrono::steady_clock::now();
    auto input_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_input_time_).count();
    auto output_elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - last_output_time_).count();
  
    if (input_elapsed > AUDIO_POWER_TIMEOUT_MS && codec_->input_enabled()) {
        codec_->EnableInput(false);
    }
  
    // 新增：检查设备状态，speaking 期间抑制自动关断
    auto& app = Application::GetInstance();
    bool is_speaking = (app.GetDeviceState() == kDeviceStateSpeaking);
  
    if (output_elapsed > AUDIO_POWER_TIMEOUT_MS && codec_->output_enabled()) {
        // 修改：speaking 状态下延长超时时间或直接跳过关闭
        if (is_speaking) {
            // 方案1：speaking 期间动态延长超时（推荐）
            const uint32_t SPEAKING_POWER_TIMEOUT_MS = 60000; // 60秒
            if (output_elapsed <= SPEAKING_POWER_TIMEOUT_MS) {
                return; // 仍在延长超时窗口内，不关闭
            }
            // 方案2：speaking 期间完全跳过关闭（备选）
            // return; // 直接返回，不关闭输出
        }
        codec_->EnableOutput(false);
    }
  
    if (!codec_->input_enabled() && !codec_->output_enabled()) {
        esp_timer_stop(audio_power_timer_);
    }
}
```

**关键变更**：

- 添加 `Application::GetInstance()` 获取设备状态
- speaking 状态下延长超时时间至60秒
- 或 speaking 期间完全跳过自动关闭

#### 修改点5：`main/audio/audio_service.h` - 添加刷新输出时间方法

**位置**：在 `CheckAndUpdateAudioPowerState()` 声明附近

**新增方法**：

```cpp
// 刷新输出时间戳，用于首包保护
void RefreshOutputTime() {
    last_output_time_ = std::chrono::steady_clock::now();
}
```

#### 修改点6：`main/application.cc` - tts start 时刷新输出时间

**位置**：`477:518:main/application.cc` - `OnIncomingJson()` 中 tts start 处理

**修改方案**：

```cpp
if (strcmp(state->valuestring, "start") == 0) {
    Schedule([this]() {
        aborted_ = false;
      
        // 记录 tts start 时间，用于通道关闭保护
        last_tts_start_time_ms_ = esp_timer_get_time() / 1000;
      
        // 新增：刷新音频输出时间，为首包到达预留缓冲
        audio_service_.RefreshOutputTime();
      
        // ... 现有代码：确保音频通道打开、启用输出 ...
    });
}
```

### 11.4 外设调度改造（阶段B）

#### 修改点7：`main/application.h` - 添加外设 Worker Task 声明

**位置**：在 `MainEventLoop()` 声明附近

**新增成员**：

```cpp
// 外设工作任务队列
QueueHandle_t peripheral_task_queue_;
TaskHandle_t peripheral_worker_task_handle_;

// 外设动作事件类型
enum class PeripheralAction {
    kEarEmotion,      // 触发耳朵情绪动作
    kEarSequence,     // 执行耳朵序列
    kEarStop,         // 停止耳朵动作
    // 可扩展：灯光、风扇等
};

struct PeripheralTask {
    PeripheralAction action;
    std::string emotion;  // 用于情绪触发
    // 其他参数...
};

void PeripheralWorkerTask();
```

#### 修改点8：`main/application.cc` - 实现外设 Worker Task

**位置**：在 `Start()` 方法中创建任务

**实现方案**：

```cpp
void Application::Start() {
    // ... 现有初始化代码 ...
  
    // 创建外设工作任务队列
    peripheral_task_queue_ = xQueueCreate(10, sizeof(PeripheralTask*));
  
    // 创建外设 Worker Task（优先级5，低于主循环）
    xTaskCreate([](void* arg) {
        ((Application*)arg)->PeripheralWorkerTask();
        vTaskDelete(NULL);
    }, "peripheral_worker", 2048, this, 5, &peripheral_worker_task_handle_);
  
    // ... 其他初始化 ...
}

void Application::PeripheralWorkerTask() {
    PeripheralTask* task = nullptr;
    while (true) {
        if (xQueueReceive(peripheral_task_queue_, &task, portMAX_DELAY) == pdTRUE) {
            auto ear_controller = Board::GetInstance().GetEarController();
          
            // 检查设备状态，speaking 首包窗口期延后大动作
            bool is_speaking = (device_state_ == kDeviceStateSpeaking);
            uint64_t current_time_ms = esp_timer_get_time() / 1000;
            bool recent_tts_start = (last_tts_start_time_ms_ > 0 && 
                                     (current_time_ms - last_tts_start_time_ms_) < 2000); // 2秒窗口
          
            if (is_speaking && recent_tts_start) {
                // speaking 首包窗口期，延迟执行大动作
                ESP_LOGI(TAG, "Delaying peripheral action during speaking first packet window");
                vTaskDelay(pdMS_TO_TICKS(2000)); // 延迟2秒
            }
          
            switch (task->action) {
                case PeripheralAction::kEarEmotion:
                    if (ear_controller) {
                        ear_controller->TriggerEmotion(task->emotion.c_str());
                    }
                    break;
                // ... 其他动作处理 ...
            }
          
            delete task;
        }
    }
}
```

#### 修改点9：`main/ear/tc118s_ear_controller.cc` - 定时器回调改为事件投递

**位置**：`704:755:main/ear/tc118s_ear_controller.cc` - `OnSequenceTimer()`

**当前问题**：

- 第714行：定时器回调中直接调用 `MoveBoth()`，可能阻塞定时器服务任务

**修改方案**：

```cpp
void Tc118sEarController::OnSequenceTimer(TimerHandle_t timer) {
    if (!sequence_active_ || current_sequence_.empty()) {
        return;
    }
  
    // 修改：不直接执行动作，而是投递事件到外设 Worker Task
    auto& app = Application::GetInstance();
  
    // 创建任务事件
    auto* task = new Application::PeripheralTask();
    task->action = Application::PeripheralAction::kEarSequence;
    // 设置序列参数...
  
    // 投递到队列（非阻塞）
    if (xQueueSend(app.GetPeripheralTaskQueue(), &task, 0) != pdTRUE) {
        ESP_LOGW(TAG, "Failed to enqueue ear sequence task, dropping");
        delete task;
        return;
    }
  
    // 更新序列状态（仅状态机，不执行动作）
    current_step_index_++;
    if (current_step_index_ >= current_sequence_.size()) {
        sequence_active_ = false;
        // 停止定时器
        if (sequence_timer_) {
            xTimerStop(sequence_timer_, 0);
        }
    } else {
        // 设置下一步定时器
        ear_sequence_step_t step = current_sequence_[current_step_index_];
        uint32_t next_delay = step.delay_ms;
        if (next_delay == 0) {
            next_delay = SCENARIO_DEFAULT_DELAY_MS;
        }
        xTimerChangePeriod(sequence_timer_, MS_TO_TICKS_MIN1(next_delay), 0);
    }
}
```

**关键变更**：

- 定时器回调中不再直接调用 `MoveBoth()`
- 改为投递事件到外设 Worker Task 队列
- 仅维护状态机，不执行耗时操作

#### 修改点10：`main/ear/tc118s_ear_controller.cc` - `MoveEar()` 移除阻塞

**位置**：`353:377:main/ear/tc118s_ear_controller.cc`

**当前问题**：

- 第371行：`vTaskDelay(pdMS_TO_TICKS(action.duration_ms))` 在任务中阻塞

**修改方案**：

- `MoveEar()` 应仅设置 GPIO，不阻塞
- 持续时间由定时器控制（已在 `MoveBoth()` 中实现）

#### 11.4.1 `Tc118sEarController` 架构优化计划（详细）

1) 运行模型与职责边界
- 控制器仅负责：GPIO 原子动作、内部状态标志、最小互斥；不管理跨模块时序。
- 所有“序列推进/情绪触发/停止”均改为：定时器回调只投递“下一步动作事件”到外设 Worker 队列，由 Worker 在线程上下文执行实际 GPIO 动作。

2) 事件模型
- 统一事件结构：`PeripheralTask { action: kEarEmotion|kEarSequence|kEarStop, emotion, step, loop, deadline }`。
- 定时器回调：仅 xQueueSend(PeripheralTask)，严禁直接 `MoveBoth/MoveEar/SetGpioLevels/vTaskDelay`。

3) 定时器策略
- 单一序列定时器 `sequence_timer_`：只负责“改期 + 投递事件”。
- 停止定时器 `stop_timer_`：仅用于“非阻塞时长控制”，到期后发出“kEarStop”事件。
- 所有延迟一律使用 `xTimerChangePeriod/xTimerStartOnce`，禁止在控制器内部 `vTaskDelay`。

4) API 与行为约束
- `MoveEar/MoveBoth`：
  - 仅设置 GPIO 电平 + 刷新内部标志（`is_active`/`moving_both_`），不得阻塞。
  - 如需时长控制，统一通过 `stop_timer_` 投递停止事件。
- `SetEarPosition`：
  - 根据当前位置计算方向与“建议时长”，仍不得阻塞；位置落点由 Worker 最终确认（必要时可投递一个“位置校准”动作）。
- `PlaySequence/StopSequence`：
  - `PlaySequence` 清空并加载步骤集，启动 `sequence_timer_`；
  - `StopSequence` 仅置 `sequence_active_=false` + 停定时器 + 投递停止事件，不直接 GPIO。

5) 并发与互斥
- 保留 `state_mutex_` 仅保护：`sequence_active_`、`emotion_action_active_`、`moving_both_`、`current_emotion_`。
- 去除跨模块大锁；GPIO 原子操作在 Worker 中执行，避免与定时器服务任务/主循环抢占。

6) 功耗与音频优先级协同
- 在 `speaking` 首包窗口（2s）内的大幅度动作延后执行（由 Application 的 Worker 统一判断，控制器不感知 DeviceState）。
- 控制器不直接操作音频/协议，仅提供轻量的“动作进行中/空闲”状态给上层做功耗策略参考。

7) 配置参数与错峰
- 软启动与错峰：取消控制器内 `xTaskCreate` 的错峰任务，改为 Worker 中按事件错峰（如 60–120ms）；控制器只保留 `SoftStartSingleEar()` 的 GPIO 原子接口供 Worker 调用。
- 冷却/最小时长：参数常量集中定义在 `tc118s_ear_controller.h`，由上层配置项驱动（后续可挂到 Settings）。

8) 代码迁移步骤（建议顺序）
- A. 将 `OnSequenceTimer()` 从直接 `MoveBoth` 改为“投递事件”（本章修改点9）。
- B. 移除 `MoveEar()` 内的 `vTaskDelay`（修改点10），由 `stop_timer_` 触发停机事件。
- C. 去除 `StartBothWithStagger()` 内 `xTaskCreate`，改在外设 Worker 实现“错峰启动”逻辑；控制器保留 GPIO 原子函数。
- D. 收敛互斥使用范围，仅保护共享标志。
- E. 增加基础自检接口（例如：`bool IsHealthy()` 返回定时器/队列句柄有效性），便于启动阶段故障兜底为 `NoEarController`。

9) 回归测试清单
- 基础动作：单耳前/后/停，双耳前/后/停，错峰启动是否生效。
- 情绪序列：全部内置情绪触发 → 执行 → 自动停机 → 中立位校准；重复触发的冷却抑制是否生效。
- 并行行为：在音频 `speaking` 期间触发耳朵动作，确认音频平滑无丢包/无卡顿（优先级验证）。
- 边界条件：快速连击触摸（去抖合并有效），弱网/丢包下 TTS 首包与耳朵动作并发可靠性；定时器改期频繁下是否丢事件。
- 资源释放：反初始化路径定时器/互斥/队列清理无泄漏。

10) 风险与回退
- 若队列满导致耳朵事件丢弃：打印一次告警并置位“需要校准”，待空闲时补一个“位置校准”事件。
- 若序列推进出现长时间停滞（>2s 未收到下一步事件）：自动 StopSequence 并复位到安全位置（DOWN/MIDDLE）。

## 12. 当前实现差距评估（2025-11-10）

- 外设任务队列仍按字节拷贝复杂对象：`Application::PeripheralTask` 当前通过 `xQueueSend`/`xQueueReceive` 直接压入 `std::string` 字段，违背 FreeRTOS 队列对 POD 数据的假设，需改为指针/索引或引入专用消息缓冲；对应阶段 B 的“Worker 统一调度”尚未完成内存安全闭环。
- 队列饱和缺乏退避策略：耳朵序列定时器在 `OnSequenceTimer()` 中以 0 等待写队列，失败不告警也不回退，无法满足第 8 节“Timer 回调零阻塞但需可靠投递”的要求。
- 错峰逻辑仍新建任务：`StartBothWithStagger()` 依赖 `xTaskCreate` + `vTaskDelay` 执行错峰，与“统一 Worker、不增新任务”目标冲突，需迁移到 Worker 中实现。
- 阶段 A 触摸链路改造已上线：`HandleTouchEventInIdleState()`、`OnTouchTimeout()`、`tts start` 分支已引入非阻塞超时和首包保护，应结合上述外设改造继续验证弱网与多触摸场景。

### 12.1 下一步优化方案

1. **外设消息结构重构**  
   - 设计 `PeripheralTask` 的轻量消息版本（仅保存动作枚举、参数索引或共享指针），改为在堆上分配任务对象并通过队列传递指针，或使用 `StaticQueue_t + message buffer` 搭配 placement new。  
   - 为队列发送/接收补充构造与析构钩子，禁止 `std::string` 等非平凡类型直接拷贝，确保内存生存期由生产者/消费者一致管理。  
   - 同步更新 `SchedulePeripheralEmotion()`、`OnSequenceTimer()` 等入口，统一封装 `EnqueuePeripheralTask()` 接口，集中处理分配失败与回收。

2. **队列饱和与退避策略**  
   - 增加 `xQueueSend` 失败返回值检查，打印带上下文的告警并统计丢弃次数。  
   - 引入轻量退避：在主循环侧检测队列满时，将任务重新排入 `Schedule()` 或设置限流标志；耳朵序列可改用 `xTimerPendFunctionCall` 发往 Worker，失败时重试。  
   - 配置 `peripheral_task_queue_` 深度（默认 16）为可调参数，并提供监控指标输出。

3. **错峰逻辑迁移至 Worker**  
   - 移除 `StartBothWithStagger()` 内部 `xTaskCreate`，改为向 Worker 投递“组合动作 + 错峰策略”消息，由 Worker 中根据 `EAR_START_STAGGER_MS` 使用 `vTaskDelay` 或定时器处理。  
   - 在 Worker 执行上下文中保证 GPIO 操作与延迟完全异步，避免短生命周期任务占用调度器。  
   - 校验 Worker 优先级与音频任务之间的关系，确保错峰逻辑不会阻塞高优任务。

4. **综合回归与监控补强**  
   - 在完成上述调整后，扩展监控日志：记录队列使用率、发送失败次数、错峰执行耗时。  
   - 重新执行阶段 B、C 的弱网、连续触摸、耳朵情绪组合压测，验证无新竞态或丢失事件。  
   - 若引入新的资源（内存池/指针），补充异常路径和回收逻辑，以防止泄漏。
### 11.5 任务优先级校准（阶段B）

#### 修改点11：`main/audio/audio_service.cc` - 确认任务优先级

**位置**：`76:110:main/audio/audio_service.cc` - `Start()` 方法

**当前优先级**：

- `audio_input_task_`: 8（CONFIG_USE_AUDIO_PROCESSOR）或 8（非）
- `audio_output_task_`: 4
- `opus_codec_task_`: 需要确认

**建议调整**：

- `opus_codec_task_`: 优先级 6（高于主循环的3，低于网络回调）
- `audio_output_task_`: 保持 4
- `audio_input_task_`: 保持 8

#### 修改点12：`main/application.cc` - 主循环优先级

**位置**：`377:380:main/application.cc` - `Start()` 方法

**当前优先级**：3

**建议**：保持 3，确保低于音频任务（4+），高于外设 Worker（5）

### 11.6 首包监控（阶段C）

#### 修改点13：`main/application.cc` - 添加首包监控

**位置**：在 `OnIncomingJson()` 和 `OnIncomingAudio()` 中

**实现方案**：

```cpp
// 在 application.h 中添加成员变量
uint64_t first_packet_arrival_time_ms_ = 0;
bool first_packet_monitoring_ = false;

// 在 tts start 处理中
if (strcmp(state->valuestring, "start") == 0) {
    first_packet_monitoring_ = true;
    first_packet_arrival_time_ms_ = 0;
    // ... 其他代码 ...
}

// 在 OnIncomingAudio 中
protocol_->OnIncomingAudio([this](std::unique_ptr<AudioStreamPacket> packet) {
    if (device_state_ == kDeviceStateSpeaking) {
        // 首包监控
        if (first_packet_monitoring_ && first_packet_arrival_time_ms_ == 0) {
            first_packet_arrival_time_ms_ = esp_timer_get_time() / 1000;
            uint64_t elapsed = first_packet_arrival_time_ms_ - last_tts_start_time_ms_;
            if (elapsed > 3000) { // 超过3秒
                ESP_LOGW(TAG, "First packet delay: %llu ms (threshold: 3000 ms)", elapsed);
            }
            first_packet_monitoring_ = false;
        }
      
        audio_service_.PushPacketToDecodeQueue(std::move(packet));
    }
});
```

## 12. 实施计划（建议分阶段）

### 阶段 A（快速止血，1-2 天）

**优先级：高**

1. **修改点1**：触摸按钮回调优化（通过调度器管理ear动作）
2. **修改点2**：触摸链路去监听化（`HandleTouchEventInIdleState`）
3. **修改点4**：speaking 期间抑制自动关断（`CheckAndUpdateAudioPowerState`）
4. **修改点5-6**：`tts start` 刷新 `last_output_time_`
5. （新增策略落地）为 `ProcessTouchEvent` 增加“重试退避与上限”“触摸去抖/合并”，并优化 `listening → idle` 的协议与状态切换顺序（同闭包执行）。

**验证**：触摸事件后，等待 tts start 而不立即进入 listening；speaking 期间音频输出不被误关闭。

### 阶段 B（结构优化，3-5 天）

**优先级：中**

1. **修改点7-8**：引入外设 Worker Task
2. **修改点9-10**：Ear 定时器回调改为事件投递，移除阻塞调用
3. **修改点11-12**：校准任务优先级
4. （新增策略落地）speaking 中断后的触摸处理加“短延迟/确认条件”，降低与回放残留竞争；完善主循环与外设 Worker 的并行配合。

**验证**：定时器回调零阻塞；外设动作通过统一队列调度；任务优先级符合设计。

### 阶段 C（完善与验证，3-5 天）

**优先级：低**

1. **修改点13**：首包监控机制
2. 板级一次性关断与 AudioService 策略对齐（需检查各板级实现）
3. 失败回退机制（连续超时处理）
4. 压测：开机首次触摸、连续触摸/唤醒、弱网/丢包下的回放可靠性

**验证**：首包延迟可监控；各种场景下回放可靠性达标。

## 13. 预期收益

- 首包可用性显著提升，触摸/唤醒路径行为一致。
- Timer Service 压力降低，竞态与时序抖动减少。
- 架构职责清晰，便于后续维护与扩展（新增外设按统一模式接入）。

## 14. 注意事项

### 14.1 循环依赖问题

- `AudioService::CheckAndUpdateAudioPowerState()` 需要访问 `Application::GetInstance()`，需确保不形成循环依赖。
- 建议：`AudioService` 通过回调或接口获取设备状态，而非直接包含 `application.h`。

### 14.2 内存管理

- 外设 Worker Task 队列中的 `PeripheralTask` 需要正确释放，避免内存泄漏。
- 建议：使用智能指针或 RAII 模式管理任务对象。

### 14.3 线程安全

- `device_state_` 的访问需要保证线程安全（当前通过 `Schedule()` 在主循环中串行化）。
- 外设 Worker Task 访问 `device_state_` 时需注意竞态条件。

### 14.4 向后兼容

- 修改触摸链路流程可能影响现有行为，需要充分测试。
- 建议：添加配置开关，支持新旧两种模式切换。

---

该方案兼顾"快速止血"与"结构改良"，优先保障音频/网络关键路径的实时性与稳定性，再逐步把外设并发行为收敛到统一调度模型下。

## 15. 兴奋情绪失控问题复盘与最终对策

- **问题根因**  
  - `MoveBoth()` 进入 `moving_both_ == true` 的再入分支后仅刷新停止定时器，后续步骤无法更新 GPIO，导致耳朵保持第一次动作方向；  
  - 序列步骤仍通过定时器回调串行推进，但动作实际执行上下文在外设 Worker，彼此状态不同步，Stop 定时器被不断延后，呈现“电机一直转”的现象。
- **设计级修正**  
  - 将 `MoveBoth()` 的状态机拆成“动作参数”和“动作执行”两层，允许后续步骤在 `combo_action` 变化时立即刷新 GPIO；  
  - `moving_both_` 仅用于表示“当前存在有效动作”，而非阻止所有再入；新增 `current_combo_action_` 用于对比是否需要实际刷新；  
  - 定时器只负责触发“停止事件”，不可再被无条件刷新，避免拖延归零。
- **统一调度流程**  
  1. 序列定时器 → 投递 `PeripheralTask`（动作参数、步序号、持续时间）；  
  2. 外设 Worker → 根据 `combo_action` 调用控制器原子接口，同时登记实际动作开始时间；  
  3. Worker 根据持续时间在自身上下文安排 `kEarStop`（或改期），不再让控制器内部定时器负责错峰。  
  这样可以确保“谁发起动作，谁负责停止”，避免状态分散。
- **安全兜底**  
  - Worker 每次执行完组合动作后，如果发现上一次 Stop 异常（例如 2 倍时长仍未落地），主动调用 `SetEarFinalPosition()` 并打印告警；  
  - 控制器保留 `ForceResetAllStates()`，由应用在检测到“连续触发失败”时触发。
- **升级路径**  
  - 阶段 B：实现 Worker 执行侧的 GPIO 刷新与错峰；重构 `MoveBoth()` 状态机；  
  - 阶段 C：增加“序列一致性检查”与“Stop 定时器健康监控”指标，持续验证弱网和高并发场景。
- **测试要求**  
  - 兴奋（`excited`）序列需连续执行 10 次，确认每一步动作方向正确、无长时保持；  
  - speaking 首包窗口内触发该序列，验证音频不受干扰且耳朵按节奏恢复中立位；  
  - 断电/复位后执行 `ForceResetAllStates()`，确保 GPIO 状态与互斥锁全部复位。
