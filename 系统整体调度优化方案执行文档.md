# 系统整体调度优化方案执行文档

本文件将《系统整体调度优化方案文档》固化为可执行的阶段计划、任务清单、接口改动点、测试与验收标准，以及风险与回退策略，指导实施落地。

## 1. 目标与范围

- 音频首包可靠、可预期，杜绝“有文本无音频”。
- 统一调度模型，降低多源并发导致的时序不确定性。
- 定时器回调零阻塞，降低 Timer Service 压力。
- 保障音频/网络关键路径优先级不受外设干扰。

适用范围：`main/application.*`、`main/audio/*`、`main/protocols/*`、`main/ear/*`、板级 `AudioCodec` 实现。

## 2. 里程碑与节奏

- 阶段 A（快速止血，1-2 天）：触摸链路去监听化、speaking 期间音频保护、首包保护与非阻塞超时。
- 阶段 B（结构优化，3-5 天）：外设 Worker 引入、耳朵控制器定时器事件化、任务优先级校准。
- 阶段 C（完善与验证，3-5 天）：首包监控、失败回退、板级对齐、压测与回归。

每阶段均需完成：代码变更、单元/集成测试、回归验证、风险评估与记录。

## 2.1 当前代码审查摘要（2025-11-10）

- 外设队列内存安全：`Application::PeripheralTask` 含有 `std::string`，但当前通过 `xQueueSend` 将结构体直接写入 FreeRTOS 队列（例如 `application.cc` 的 `SchedulePeripheralEmotion()`、`tc118s_ear_controller.cc` 的 `OnSequenceTimer()`），属按字节拷贝非 POD 对象，存在重复释放与指针失效风险。需改为传递索引/指针或引入显式构造与析构策略。
- 外设任务丢弃无告警：`OnSequenceTimer()` 在队列满时直接丢弃动作且缺少回退/日志；`peripheral_task_queue_` 深度仅 16，序列/触摸并发容易触发饱和，需补充限流或失败处理。
- 耳朵动作仍依赖临时任务：`StartBothWithStagger()` 仍通过 `xTaskCreate`+`vTaskDelay` 错峰驱动，尚未完全迁移到外设 Worker；与阶段 B“定时器回调事件化、无新任务”目标不符。
- 触摸链路阶段 A 基本落地：`HandleTouchEventInIdleState()` 已取消即时 `SetListeningMode`，并结合 `touch_timeout_timer_`、`direct_speaking_protection_mode_` 控制回退；`tts start` 分支会刷新输出时间与重新启用音频。后续需结合队列安全性改造验证弱网场景。

### 2.2 下一步执行细节

#### 任务 1：外设消息结构重构（负责人：应用架构组，预计 1 天）
- 新建 `PeripheralTaskMessage` 结构，包含 `action`、`combo_id`、`duration_ms`、`emotion_id` 等基础字段，改为在堆上创建消息并通过队列传递指针；提供 `CreatePeripheralTaskMessage()`、`DestroyPeripheralTaskMessage()` 辅助函数。
- 修改 `SchedulePeripheralEmotion()`、`SchedulePeripheralSequence()`、`OnSequenceTimer()` 等调用点，统一使用新的创建/销毁接口，并在 `PeripheralWorkerTask()` 内负责释放。
- 更新单元测试：模拟快速触发触摸与情绪，验证无内存破坏（可结合 ASAN/heap poisoning）。

#### 任务 2：队列饱和与退避策略（负责人：系统调度组，预计 1 天并行进行）
- 为 `EnqueuePeripheralTask()` 添加返回值判断，失败时记录日志（含动作类型、当前队列深度、设备状态），并累加统计计数。
- 若队列满：  
  1）对触摸触发的情绪，回退到主循环中延迟重试（使用已有 `touch_retry_timer_` 或新增 `peripheral_retry_timer_`）；  
  2）对自动序列，允许掉队但同时置位“序列丢帧”标志，待 Worker 空闲时补发 `SetEarInitialPosition()` 进行校准。
- 在 `PeripheralWorkerTask()` 内增加简单水位监控（例如每处理 10 个任务打印一次空闲长度），并暴露给调试命令。

#### 任务 3：错峰逻辑迁移到 Worker（负责人：外设组，预计 2 天）
- 移除 `StartBothWithStagger()` 中的 `xTaskCreate`，将错峰逻辑封装为 Worker 内的辅助函数；Worker 收到组合动作后根据配置执行 `{设置左耳 → vTaskDelay → 设置右耳}`。
- 对所有触发双耳组合的路径（情绪序列、测试函数等）统一通过队列派发，删除临时任务创建代码。
- 回归测试：执行 `TestEarSequences()`、连续触发情绪、在 speaking 首包窗口触发耳朵动作，确认无新任务创建且动作按预期执行。

#### 任务 4：回归验证与监控增强（负责人：QA/运维联合，预计 1 天）
- 新增调试指标：  
  - `peripheral_queue_max_depth`（运行期最大占用）；  
  - `peripheral_queue_drop_count`；  
  - `peripheral_task_retry_count`。  
  通过串口命令或 Web 界面输出。
- 重新执行阶段 B/C 的场景测试：弱网（30% 丢包）、连续触摸≥20次、speaking 期间耳朵情绪并发，记录指标并与当前基线对比。
- 如发现遗漏，及时反馈至对应负责人，纳入补充任务。

## 3. 执行项总览（按阶段）

### 3.1 阶段 A（快速止血）

1) 触摸链路去监听化（必要）
- 位置：`main/application.cc` → `HandleTouchEventInIdleState()`；`OnIncomingJson()` tts start 分支。
- 动作：
  - 发送触摸文本后，不立即 `SetListeningMode`；启动 `esp_timer` 非阻塞超时（建议 3s，可配置）。
  - 收到 `tts start`：取消超时、`SetDeviceState(kDeviceStateSpeaking)`、`EnableOutput(true)`、刷新 `AudioService::last_output_time_`。
  - 超时：未 speaking 才进入 `listening` 作为回退。

2) speaking 期间抑制自动关断
- 位置：`audio/audio_service.cc` → `CheckAndUpdateAudioPowerState()`。
- 动作：speaking 状态下延长输出关断阈值（建议 60s）或直接跳过关断；保持定时器活跃以监测状态。

3) 协议/状态一致性（同闭包）
- 位置：`main/application.cc` → `ProcessTouchEvent()` 的 `listening` 分支。
- 动作：`protocol_->SendStopListening()` 与 `SetDeviceState(kDeviceStateIdle)` 置于同一次 `Schedule` 闭包内执行，避免跨 tick 抖动。

4) 首包保护
- 位置：`OnIncomingJson()` tts start；`AudioService::AudioOutputTask()` 已更新 `last_output_time_`。
- 动作：收到 tts start 即刷新 `last_output_time_`；speaking 期间输出保持开启。

验收标准（阶段 A）：
- 触摸后常规网络下 ≤2s 切换到 speaking；弱网下 3s 超时进入 listening，无“有文本无音频”。
- speaking 期间无自发关闭输出；音频通道异常关闭可在 5s 内重开并继续播放。

### 3.2 阶段 B（结构优化）

1) 外设 Worker 引入
- 位置：`main/application.h/.cc`。
- 动作：
  - 新增 `peripheral_task_queue_`、`PeripheralWorkerTask()` 与 `PeripheralTask` 结构体；
  - 统一耳朵/灯光等外设动作经队列投递在 Worker 执行（优先级低于主循环）。

2) 耳朵控制器事件化与去阻塞
- 位置：`main/ear/tc118s_ear_controller.cc/.h`。
- 动作：
  - `OnSequenceTimer()` 仅“改期 + 投递事件”，不直接驱动 GPIO；
  - `MoveEar/MoveBoth/SetEarPosition` 禁止阻塞，时长用定时器触发 `kEarStop` 事件；
  - 移除控制器内 `xTaskCreate` 启动错峰，改由 Worker 侧实现错峰策略。

3) 任务优先级校准
- 动作：确保 音频输入(8) > 编解码(6) > 输出(4) > 主循环(3) > 外设 Worker(5)；根据平台情况微调但保持相对关系。

4) `ProcessTouchEvent` 调度收尾
- 动作：
  - connecting/default 分支加入退避与最大重试（如 50→100→200→400→800ms，最多 3-5 次）；
  - speaking 分支 Abort 后短延迟或确认条件（播放队列清空/通道关闭）再进入下一步；
  - 触摸去抖/合并（例如 200ms 窗口）。

验收标准（阶段 B）：
- 定时器回调无阻塞痕迹，外设动作与音频/网络并行且不抢占关键路径。
- 连续触摸/弱网/丢包下稳定无明显时序抖动或卡顿。

### 3.3 阶段 C（完善与验证）

1) 首包监控与指标
- 位置：`application.cc` → 记录 `tts start → 第一个UDP包` 耗时，超阈值打印/统计。

2) 失败回退策略
- 连续 2-3 次触摸超时后，临时启用“触摸→直接 speaking 保护模式”（跳过 listen+start）。

3) 板级对齐
- 检查板级一次性关断与 `AudioService` 策略一致性，speaking 期间延后或禁用一次性关断。

4) 压测回归
- 场景：开机首次触摸；连续触摸/唤醒；弱网/丢包；通道异常关闭/重开；长时间运行。

验收标准（阶段 C）：
- 首包延迟统计指标可用；各场景回放可靠性达标，无致命回归。

## 4. 关键代码改动点（索引）

- `main/application.cc`：
  - `HandleTouchEventInIdleState()`：去监听化 + 非阻塞超时 + speaking 输出保障。
  - `OnIncomingJson()` tts start：刷新 `last_output_time_`、取消超时、切 speaking。
  - `ProcessTouchEvent()`：退避、去抖、同闭包协议→状态顺序、speaking 中断保护。
- `audio/audio_service.cc`：
  - `CheckAndUpdateAudioPowerState()`：speaking 期间延长/跳过关断；保持定时器活跃。
- `main/ear/tc118s_ear_controller.cc/.h`：
  - 定时器回调事件化、去 `vTaskDelay`、错峰迁移至 Worker、互斥收敛。

## 5. 测试计划与验收清单

1) 功能用例
- 触摸→tts start 正常路径：speaking 切换、音频可闻、无误关断。
- 触摸超时路径：3s 未到 tts start 自动 listening 回退。
- speaking 期间触发耳朵动作：音频平滑不抖动，耳朵动作并行可见。
- 通道异常关闭：5s 窗口重开成功并继续播放。

2) 稳定性/并发
- 连续触摸（≥20 次）：无队列爆炸、无主循环阻塞、无耳朵动作丢失。
- 弱网/丢包 10%-30%：首包仍可达（或按预期回退），无“有文本无音频”。

3) 性能与资源
- Timer Service 负载：无长回调；定时器个数与周期合理。
- 内存泄漏：长时间运行监控无持续上升。

4) 验收标准（关键阈值参考）
- 正常网络：触摸→speaking ≤ 2s；弱网：≤ 3s 或回退 listening。
- speaking 期间输出不开；异常关闭可在 5s 内重开。

## 6. 监控指标与排障

- 首包延迟：`tts start → 首个UDP`，统计/日志告警阈值 3s。
- 通道异常重开次数与成功率。
- Timer 回调耗时采样（需在开发版打开）。

## 7. 风险与回退策略

- 触摸链路新逻辑影响行为：提供配置开关，支持新旧模式切换。
- 外设事件队列满：打印告警，置位“需要校准”，空闲时补发“位置校准”。
- 序列推进停滞 > 2s：自动 `StopSequence` 并复位到安全位置（DOWN/MIDDLE）。

## 8. 实施顺序建议（跨团队）

1) 应用/协议组（阶段 A 为主）：
- 去监听化与非阻塞超时；speaking 保护；协议-状态顺序收敛；退避与去抖。

2) 音频组（阶段 A & C）：
- speaking 电源策略修正；首包监控接入；回放稳定性压测。

3) 外设/板级组（阶段 B 为主）：
- 外设 Worker 引入；耳朵控制器事件化与去阻塞；板级一次性关断对齐。

## 9. 交付物

- 代码合入：上述改动点涉及的源文件。
- 配置项：触摸超时、speaking 保护开关、错峰参数、冷却时间等。
- 文档：
  - 实施记录与变更说明；
  - 测试报告与监控截图；
  - 回退方案说明。

## 13. 兴奋情绪调度异常专项方案落地

### 13.1 现象复盘与监测项

- 复现症状：触发 `excited` 等多步情绪时，串口持续打印 `MoveBoth re-entry: refresh timer only`，耳朵保持第一次动作方向不再切换，直至 Stop 定时器到期。
- 监测指标：
  - 新增 `ear_current_combo_action`、`ear_last_combo_update_ms`，用于判定组合动作是否及时刷新；
  - Stop 定时器触发延迟超过设定值 1.5 倍时输出 WARN，并计入 `ear_stop_delay_overrun`。

### 13.2 目标与验收标准

- 序列每一步动作必须落地到 GPIO，组合动作切换不被抑制；
- speaking 首包窗口内耳朵动作不影响音频输出连续性；
- 队列饱和或 Stop 定时器异常时能自恢复至安全位置（MIDDLE→DOWN）；
- 连续压测 10 轮 `excited` 情绪无异常日志且耳朵最终回到中立位。

### 13.3 实施步骤

1. **状态机重构**（阶段 B，负责人：外设组，1 天）  
   - 在 `tc118s_ear_controller` 内新增 `current_combo_action_`、`last_combo_start_time_ms_`；  
   - `MoveBoth()` 允许 `combo_action` 变化时立即刷新 GPIO，并将 `moving_both_` 改为仅表示“当前存在动作”；  
   - `OnStopTimer()` 只在真正停止时清空状态，不再被再入逻辑无条件刷新。
2. **Worker 接管生命周期**（阶段 B，负责人：外设组，1 天）  
   - `PeripheralWorkerTask()` 增加 `ProcessEarComboTask()`，负责调用 `SoftStartSingleEar()`、执行错峰，并在自身上下文安排 `kEarStop`；  
   - 控制器内部 stop timer 仅保留单耳用途，组合动作停止完全由 Worker 决定。
3. **序列投递增强**（阶段 B，负责人：系统调度组，1 天）  
   - `OnSequenceTimer()` 投递动作时附带“步序号 + combo_action + duration`；  
   - 队列满时退避三次（50ms/100ms/200ms），失败则调用 `StopSequence()` 并触发 `SetEarFinalPosition()`；  
   - 投递失败打印 `EAR_SEQ_DROP`，统计到 `ear_sequence_drop_count`。
4. **健康监控与兜底**（阶段 C，负责人：系统调度组，0.5 天）  
   - 记录每个动作实际持续时间，超 1.5× 目标值立即触发 `ForceResetAllStates()` 并输出 WARN；  
   - 串口调试命令新增 `ear_stats`，展示 overrun 次数、最大 stop 延迟、最近队列深度。
5. **专项压测**（阶段 C，负责人：QA，1 天）  
   - 在 speaking 首包窗口内连续触发 `excited` 10 轮；  
   - 弱网（30% 丢包）环境重复执行情绪序列，验证动作节奏与停止可靠性；  
   - 验证 `ForceResetAllStates()` 后耳朵能回到 DOWN 并重新触发情绪。

### 13.4 风险与回退

- 若 Worker 接管停止逻辑引发异常，可通过 `CONFIG_EAR_STOP_IN_WORKER` 开关回退至旧模式，由控制器 stop timer 主导；
- 状态机重构需关注 `state_mutex_` 使用范围，防止新旧标志混用导致死锁；
- 合入前在开发固件进行 24h 自动巡检，确保无内存泄漏或队列任务堆积。

### 13.5 输出物

- 代码改动：`tc118s_ear_controller.h/.cc`、`application.h/.cc`、相关 Kconfig；
- 监控脚本：串口调试命令、统计指标；
- 测试报告：专项压测结果、回退验证记录。


